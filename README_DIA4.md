#Advent of Code 
Memoria dia 4

ELECCION
Elegimos este problema del Advent of Code ya que nos pareció interesante a nivel algorítmico, así como vimos la posibilidad de implementar estructuras dadas en la asignatura durante el curso, como pueden ser los grafos. Además, consideramos que el problema podría ser un reto para el grupo, por su complejidad y el intento de buscar una solución óptima entre todos.

TECNICAS Y ESTRUCTURAS EMPLADAS
En cuanto a la técnicas y estructuras que se han implementado,  para la primera parte del problema  han sido las siguientes: Para la lectura de archivos se ha utilizado ifstream y getline(). También se ha usado una matriz de string, que nos permitía usar el documento como una matriz. Para mirar los rollos vecinos, se ha usado desplazamientos(df, dc) que representaban las 8 direcciones alrededor de la celda. Esta técnica se ha usado como un grafo implícito, donde cada celda es un nodo y las aristas son las adyacencias.
En cuanto a la segunda parte del problema, en esta se ha añadido vector<int> fil, col para ir almacenando las coordenadas de de los rollos a los que se ha accedido. Se ha seguido usando los desplazamientos como representaciones de las 8 direcciones, realizando así un grafo implícito.

RESOLUCION DEL PROBLEMA
El objetivo de la primera parte del problema era determinar a cuántos rollos se podían acceder que cumplieran la condición de que el total de adyacentes en las 8 direcciones que tuvieran un rollo fuera menos que 4.  Para la lectura de archivos se ha utilizado ifstream, para recorrer cada línea del fichero (mediante un getline()) que contiene la representación de la cuadrícula con rollos ( @ ) y espacios ( . ). Después se ha transformado el documento en una matriz de string. Para mirar los rollos vecinos, se ha usado desplazamientos(df, dc, implementados en la función comprobar) que representaban las 8 direcciones alrededor de la celda. Para comprobar cuántas adyacencias tiene un vecino se ha usado la función comprobar que devuelve True si había menos de 4 adyacencias. Por último se recorren todas las posiciones de la matriz y se aplica la función comprobar a cada celda que contiene un rollo ( @ ) y se van contando todas aquellas que cumplen la condición, para sacar el número por pantalla.
En cuanto a la segunda parte del problema, el objetivo era comprobar cuántos rollos eran accesibles si al realizarse el proceso de accesibilidad, estos rollos se eliminaban y se repetía el proceso. Aquí se ha realizado una extensión de la primera parte, añadiendo la función de eliminar (se encarga de eliminar los rollos accesibles). Primero se carga la matriz, después se recorren todas las celdas y se identifican las accesibles, almacenando sus coordenadas en fil y col, estas son eliminadas y se repite el proceso de búsqueda. Se van acumulando el número de rollos eliminados en solución, el cual representa el total de rollos que el montacargas puede retirar.

ALTERNATIVAS RECHAZADAS
Por otro lado, también se había optado por intentar realizar el problema entero (primera y segunda parte) con un grafo explícito, en el que cada celda se consideraba un nodo y las adyacencias eran las aristas de este. En la primera parte se observaba las adyacencias que tuvieran un rollo y se añadían a un contador, que utilizamos al final para ver si cumplía con la condición de ser menor que 4. En la segunda parte se utilizaba un función recursiva en la cual se iba modificando el grafo en cada llamada. Sin embargo, esto añadía una complejidad que finalmente se consideró innecesaria ya que la cuadrícula ya actuaba como un grafo implícito.

VALORACION GRUPAL
Finalmente, todos los miembros del grupo han coincidido en que la resolución de este problema nos permitió aplicar conceptos vistos en clase, como lo pueden ser los grafos. Durante la resolución surgió la duda de que manera de implementar grafos en este problema seria la mas optima (implícita o explícita), sin embargo finalmente optamos por la implícita, por su claridad y efectividad, esto nos ayudó a comprender mejor las estructuras. En conjunto, el grupo  lo considera  como un buen problema para poder afianzar conocimientos. 
